(filter #(zero? (mod 51 %)) [5 25])
(take-while #(< % 51) (iterate (partial + 5) 5))
(conj #{} 3 4 5 1 2 3)
(require 'sum-of-multiples)
(sum-of-multiples/get-multiples 25 51)
(take-while #(< % 51) (iterate (partial + 5) 5))
(map (fn [a b] (take-while #(< % b) (iterate (partial + a) a))) [5 25] [51])
(reduce + 0 (map (fn [a b] (take-while #(< % b) (iterate (partial + a) a))) [5 25] [51]))
(reduce + 0 (first (map (fn [a b] (take-while #(< % b) (iterate (partial + a) a))) [5 25] [51])))
(vec 54)
(vector 54)
(take-while #(< % 51) (iterate (partial + 5) 0))
(take-while #(< % 4) (iterate (partial + 5) 0))
(take-while #(< % 4) (iterate (partial + 3) 0))
(take-while #(< % 4) (iterate (partial + 5) 0))
(require 'sum-of-multiples)
(sum-of-multiples/complete-set [[3 5] 4])
(sum-of-multiples/complete-set [3 5] 4)
(sum-of-multiples/multiples-of 3 4)
(sum-of-multiples/multiples-of 5 4)
(require 'sum-of-multiples)
(sum-of-multiples/complete-set [3 5] 4)
(flatten (sum-of-multiples/complete-set [3 5] 4))
(sum-of-multiples/multiples-of 5 4)
(conj #{} (sum-of-multiples/multiples-of 5 4))
(map #(conj #{} %) (sum-of-multiples/multiples-of 5 4))
(union '(0) '(0 5))
(clojure.set/union '(0) '(0 3 5))
(into #{} (clojure.set/union '(0) '(0 3 5)))
(doc transduce)
